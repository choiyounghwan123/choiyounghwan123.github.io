---
title: "[프로그래머스] 주식 가격"
excerpt: "이중 반복문을 활용한 주식 가격 문제 풀이"

categories:
  - Algorithm
tags:
  - [프로그래머스, Python, 배열]

permalink: /algorithm/stock-price/

toc: true
toc_sticky: true

date: 2025-05-27
last_modified_at: 2025-05-27
---

# 문제 설명

초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

# 제한사항

- prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
- prices의 길이는 2 이상 100,000 이하입니다.
- 1초 시점의 ₩3은 끝까지 가격이 떨어지지 않았습니다.
- 2초 시점의 ₩2는 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
- 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
- 4초 시점의 ₩2는 1초간 가격이 떨어지지 않았습니다.
- 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.

# 입출력 예

```
입력: [1, 2, 3, 2, 3]
출력: [4, 3, 1, 1, 0]
```

# 풀이 방법

이 문제는 이중 반복문을 사용하여 해결할 수 있습니다.

1. 각 시점의 주식 가격에 대해:
   - 이후의 모든 가격과 비교합니다.
   - 가격이 떨어지는 시점을 찾거나 끝까지 가격이 유지되는 시간을 계산합니다.
2. 각 시점별로 계산된 시간을 결과 배열에 저장합니다.

# 코드

```python
def solution(prices):
    result = []
    for i in range(len(prices)):
        temp = 0
        for j in range(i+1, len(prices)):
            if prices[i] > prices[j]:  # 가격이 떨어지는 경우
                temp += 1
                break
            else:  # 가격이 유지되거나 상승하는 경우
                temp += 1
        result.append(temp)
    return result

print(solution([1, 2, 3, 2, 3]))  # [4, 3, 1, 1, 0]
```

# 코드 설명

1. `result`: 각 시점별로 가격이 떨어지지 않은 시간을 저장할 배열입니다.
2. 첫 번째 반복문에서 각 시점의 주식 가격을 순회합니다.
3. 두 번째 반복문에서 현재 시점 이후의 모든 가격과 비교합니다:
   - 현재 가격이 이후 가격보다 높으면 가격이 떨어진 것이므로 시간을 증가시키고 반복을 종료합니다.
   - 현재 가격이 이후 가격보다 낮거나 같으면 가격이 유지되거나 상승한 것이므로 시간을 증가시킵니다.
4. 각 시점별로 계산된 시간을 결과 배열에 추가합니다.

# 시간/공간 복잡도

- 시간 복잡도: O(N²)
  - N은 주식 가격 배열의 길이
  - 각 시점에 대해 이후의 모든 가격과 비교해야 합니다.
- 공간 복잡도: O(N)
  - 결과를 저장하는 배열에 O(N) 공간이 필요합니다.

이 방법을 사용하면 효율적으로 각 시점별로 가격이 떨어지지 않은 시간을 계산할 수 있습니다. 