---
title: "[프로그래머스] 디펜스 게임"
excerpt: "힙을 활용한 디펜스 게임 문제 풀이"

categories:
  - Algorithm
tags:
  - [프로그래머스, 힙, Python]

permalink: /algorithm/defense-game/

toc: true
toc_sticky: true

date: 2025-05-23
last_modified_at: 2025-05-23
---

# 문제 설명

디펜스 게임에서 적의 공격을 막아내는 문제입니다. 병사 n명과 무적권 k개를 가지고 있으며, 각 라운드마다 적의 수가 주어집니다. 무적권을 사용하면 해당 라운드의 적을 막을 수 있습니다.

- 각 라운드마다 적의 수가 주어집니다.
- 병사 수가 적의 수보다 적으면 무적권을 사용할 수 있습니다.
- 무적권을 사용하면 해당 라운드의 적을 막을 수 있습니다.
- 막을 수 있는 최대 라운드 수를 구해야 합니다.

# 제한사항

- 1 ≤ n ≤ 1,000,000,000
- 1 ≤ k ≤ 500,000
- 1 ≤ enemy의 길이 ≤ 1,000,000
- 1 ≤ enemy[i] ≤ 1,000,000

# 입출력 예

```
입력: 
n = 7
k = 3
enemy = [4, 2, 4, 5, 3, 3, 1]

출력: 5
```

# 풀이 방법

이 문제는 최대 힙을 활용하여 해결할 수 있습니다. 각 라운드의 적의 수를 힙에 저장하고, 병사 수가 부족할 때 가장 많은 적이 있는 라운드에 무적권을 사용합니다.

# 코드

```python
import heapq

def solution(n, k, enemy):
    heap = []  # 최대 힙 (음수로 저장)
    sum_enemy = 0  # 현재까지의 적의 수 합
    result = 0  # 막을 수 있는 라운드 수
    
    for e in enemy:
        heapq.heappush(heap, -e)  # 적의 수를 음수로 저장
        sum_enemy += e
        
        # 병사 수가 부족한 경우
        if sum_enemy > n:
            if not k:  # 무적권이 없는 경우
                break
            # 무적권 사용
            while k and sum_enemy > n:
                sum_enemy += heapq.heappop(heap)  # 가장 많은 적이 있는 라운드에 무적권 사용
                k -= 1
                
        result += 1
        
    return result
```

# 코드 설명

1. 변수 초기화:
   - `heap`: 최대 힙 (적의 수를 음수로 저장)
   - `sum_enemy`: 현재까지의 적의 수 합
   - `result`: 막을 수 있는 라운드 수

2. 라운드 처리:
   - 각 라운드의 적의 수를 힙에 저장합니다.
   - 현재까지의 적의 수 합을 계산합니다.
   - 병사 수가 부족한 경우:
     - 무적권이 있으면 가장 많은 적이 있는 라운드에 무적권을 사용합니다.
     - 무적권이 없으면 게임을 종료합니다.
   - 막을 수 있는 라운드 수를 증가시킵니다.

3. 결과 반환:
   - 막을 수 있는 최대 라운드 수를 반환합니다.

# 시간 복잡도

- 시간 복잡도: O(n * log n)
  - n: enemy 배열의 길이
- 공간 복잡도: O(n)

각 라운드마다 힙 연산을 수행하므로, 시간 복잡도는 enemy 배열의 길이에 비례합니다. 