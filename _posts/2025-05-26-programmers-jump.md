---
title: "[프로그래머스] 멀리 뛰기"
excerpt: "동적 프로그래밍(DP)을 활용한 멀리 뛰기 문제 풀이"

categories:
  - Algorithm
tags:
  - [프로그래머스, Python, 동적 프로그래밍, DP]

permalink: /algorithm/jump/

toc: true
toc_sticky: true

date: 2025-05-26
last_modified_at: 2025-05-26
---

# 문제 설명

멀리 뛰기를 하는 사람이 n칸을 뛰는 방법의 수를 구하는 문제입니다. 한 번에 1칸 또는 2칸을 뛸 수 있습니다.

- 한 번에 1칸 또는 2칸을 뛸 수 있습니다.
- n칸을 뛰는 방법의 수를 1234567로 나눈 나머지를 반환합니다.

# 제한사항

- 1 ≤ n ≤ 2000

# 입출력 예

```
입력:
n = 1

출력: 1
```

# 풀이 방법

이 문제는 동적 프로그래밍(DP)을 활용하여 해결할 수 있습니다. 

1. dp[i]는 i칸을 뛰는 방법의 수를 의미합니다.
2. dp[1] = 1, dp[2] = 2로 초기화합니다.
3. dp[i] = dp[i-1] + dp[i-2]로 점화식을 세워 계산합니다.
4. 최종적으로 dp[n] % 1234567을 반환합니다.

# 코드

```python
def solution(n):
    answer = 0
    dp = [0] * (n+2)
    dp[1] = 1
    dp[2] = 2

    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n] % 1234567

print(solution(1))  # 1
```

# 코드 설명

- dp 배열을 초기화하고, dp[1]과 dp[2]를 설정합니다.
- 3부터 n까지 반복하며 dp[i]를 계산합니다.
- dp[i]는 dp[i-1]과 dp[i-2]의 합으로, 이는 i칸을 뛰는 방법의 수입니다.
- 최종적으로 dp[n] % 1234567을 반환합니다.

# 시간/공간 복잡도

- 시간 복잡도: O(N)
  - n까지의 dp 값을 계산하므로 선형 시간에 해결할 수 있습니다.
- 공간 복잡도: O(N)
  - dp 배열을 저장하는 데 O(N) 공간이 필요합니다.

동적 프로그래밍을 활용하면 효율적으로 멀리 뛰기 문제를 해결할 수 있습니다. 