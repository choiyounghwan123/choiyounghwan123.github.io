---
title: "[프로그래머스] 디스크 컨트롤러"
excerpt: "힙(Heap)을 활용한 디스크 컨트롤러 문제 풀이"

categories:
  - Algorithm
tags:
  - [프로그래머스, Python, 힙, 시뮬레이션]

permalink: /algorithm/disk-controller/

toc: true
toc_sticky: true

date: 2025-05-29
last_modified_at: 2025-05-29
---

# 문제 설명

하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있는데, 요청이 들어온 순서대로 처리하는 방식(FIFO)이 아닌, 작업의 요청부터 종료까지 걸린 시간의 평균을 최소화하는 방식을 구현하려고 합니다.

작업의 요청 시점과 소요 시간이 주어졌을 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 최소화하는 방법을 구현하세요.

# 제한사항

- jobs의 길이는 1 이상 500 이하입니다.
- jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간]을 의미합니다.
- 각 작업에 대해 작업이 요청되는 시점은 0 이상 1,000 이하입니다.
- 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
- 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.

# 입출력 예

```
입력: [[0, 3], [1, 9], [2, 6]]
출력: 9
```

# 풀이 방법

이 문제는 시뮬레이션과 최소 힙(Min Heap)을 함께 사용하여 해결할 수 있습니다.

1. 현재 시간을 기준으로 처리할 수 있는 작업들을 우선순위 큐에 넣습니다.
2. 우선순위 큐에서는 작업의 소요시간이 가장 짧은 작업을 우선적으로 처리합니다.
3. 작업이 완료되면 해당 작업의 요청부터 종료까지 걸린 시간을 계산하여 결과에 추가합니다.
4. 모든 작업이 처리될 때까지 위 과정을 반복합니다.

# 코드

```python
import heapq

def solution(jobs):
    t = 0  # 현재 시간
    jobs.sort(key=lambda x:[x[0],x[1]])  # 요청 시간, 소요 시간 순으로 정렬
    queue = []  # 우선순위 큐
    current = []  # 현재 처리 중인 작업
    result = []  # 각 작업의 소요 시간을 저장할 리스트
    
    while jobs or queue or current:
        # 현재 작업이 완료되었는지 확인
        if current and current[0] == t:
            current = []
            
        # 현재 시간에 요청된 작업들을 큐에 추가
        while jobs and jobs[0][0] == t:
            a = jobs.pop(0)
            heapq.heappush(queue, [a[1], a[0]])  # [소요시간, 요청시간] 순으로 저장
            
        # 현재 처리 중인 작업이 없고, 대기 중인 작업이 있다면 처리
        if queue and not current:
            a = heapq.heappop(queue)
            current = [t + a[0], a[1]]  # [완료 시간, 요청 시간]
            result.append(t + a[0] - a[1])  # 요청부터 종료까지 걸린 시간
            
        t += 1
        
    return sum(result) // len(result)

# 테스트
print(solution([[0, 3], [0,1], [0,4], [1, 9], [1,4], [3, 5], [5,1], [1,10], [1,1000], [100,10]]))
```

# 코드 설명

1. `jobs.sort(key=lambda x:[x[0],x[1]])`: 작업을 요청 시간과 소요 시간 순으로 정렬합니다.
2. `queue`: 우선순위 큐로, 소요 시간이 가장 짧은 작업을 우선적으로 처리합니다.
3. `current`: 현재 처리 중인 작업의 [완료 시간, 요청 시간]을 저장합니다.
4. `result`: 각 작업의 요청부터 종료까지 걸린 시간을 저장합니다.

주요 로직:
- 현재 시간에 요청된 작업들을 우선순위 큐에 추가합니다.
- 현재 처리 중인 작업이 없고, 대기 중인 작업이 있다면 소요 시간이 가장 짧은 작업을 처리합니다.
- 작업이 완료되면 해당 작업의 소요 시간을 결과에 추가합니다.

# 시간/공간 복잡도

- 시간 복잡도: O(N log N)
  - N은 작업의 개수
  - 작업 정렬에 O(N log N)
  - 우선순위 큐 연산에 O(log N)
- 공간 복잡도: O(N)
  - 우선순위 큐와 결과 리스트에 필요한 공간

이 방법을 사용하면 작업의 평균 대기 시간을 최소화할 수 있습니다. SJF(Shortest Job First) 알고리즘의 변형된 형태로, 현재 처리 가능한 작업들 중에서 소요 시간이 가장 짧은 작업을 우선적으로 처리하는 방식입니다. 