---
title: "[2019 카카오 개발자 겨울 인턴십] 크레인 인형뽑기 게임"
excerpt: "스택을 활용한 크레인 인형뽑기 게임 문제 풀이"

categories:
  - Algorithm
tags:
  - [카카오, 스택, Python]

permalink: /algorithm/crane-game/

toc: true
toc_sticky: true

date: 2025-05-22
last_modified_at: 2025-05-22
---

# 문제 설명

크레인 인형뽑기 게임에서 인형을 집어서 바구니에 옮기는 문제입니다. 같은 종류의 인형이 연속으로 쌓이면 두 인형이 사라지고, 사라진 인형의 개수를 구해야 합니다.

- 게임 화면은 N x N 크기의 2차원 배열로 표현됩니다.
- 각 칸에는 0~100 사이의 정수가 있으며, 0은 빈 칸을 의미합니다.
- 크레인은 가장 위에 있는 인형을 집어올립니다.
- 같은 종류의 인형이 연속으로 쌓이면 두 인형이 사라집니다.
- 사라진 인형의 개수를 반환합니다.

# 제한사항

- board 배열은 2차원 배열로 크기는 "5 x 5" 이상 "30 x 30" 이하입니다.
- board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
- 0은 빈 칸을 나타냅니다.
- 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.
- moves 배열의 크기는 1 이상 1,000 이하입니다.
- moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

# 입출력 예

```
입력: 
board = [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]
moves = [1,5,3,5,1,2,1,4]

출력: 4
```

# 풀이 방법

이 문제는 스택을 활용하여 해결할 수 있습니다. 크레인으로 집은 인형을 스택에 쌓고, 같은 종류의 인형이 연속으로 쌓이면 제거하는 과정을 반복합니다.

# 코드

```python
def solution(board, moves):
    answer = 0
    stack = []  # 인형을 담을 바구니
    
    for move in moves:
        for i in range(len(board)):
            if board[i][move-1] != 0:  # 인형이 있는 경우
                # 같은 종류의 인형이 연속으로 쌓이는 경우
                if stack and stack[-1] == board[i][move-1]:
                    answer += 2  # 사라진 인형의 개수 증가
                    stack.pop(-1)  # 스택에서 인형 제거
                    board[i][move-1] = 0  # 보드에서 인형 제거
                    break
                # 다른 종류의 인형인 경우
                stack.append(board[i][move-1])  # 스택에 인형 추가
                board[i][move-1] = 0  # 보드에서 인형 제거
                break
                
    return answer
```

# 코드 설명

1. 변수 초기화:
   - `answer`: 사라진 인형의 개수를 저장
   - `stack`: 인형을 담을 바구니 (스택)

2. 크레인 동작:
   - 각 move에 대해 해당 열의 가장 위에 있는 인형을 찾습니다.
   - 인형이 있는 경우 (0이 아닌 경우):
     - 스택의 top과 같은 종류의 인형이면 제거하고 answer를 증가시킵니다.
     - 다른 종류의 인형이면 스택에 추가합니다.
   - 보드에서 인형을 제거합니다 (0으로 변경).

3. 결과 반환:
   - 사라진 인형의 개수를 반환합니다.

# 시간 복잡도

- 시간 복잡도: O(n * m)
  - n: board의 크기
  - m: moves의 길이
- 공간 복잡도: O(m)

각 move마다 board를 한 번씩 순회하므로, 시간 복잡도는 board의 크기와 moves의 길이의 곱에 비례합니다. 